import json
import re

"""
This module contains the functions for formatting tool message content in a standardized format across all tools.

Here is roughly what the output looks like for an tool message that triggers an artifact:

[TOOL OUTPUT: ARTIFACT DISPLAYED TO USER]
- Tool call ID: tool-call-id-123
- Artifact rendered to user: True
- Artifact name: My Student Data
- Artifact description: Upload interface for My Student Data file from studentaid.gov

[Returned Data]
- **New Starting Monthly Payment**: $0.00
- **Loan Term (Months)**: N/A
- **Total Amount Paid Over Loan Term**: $0.00
- **Amount Forgiven**: $0.00
- **Eligible Loan Count**: 3
#### Eligible Loans:
- **Name**: DIRECT STAFFORD UNSUBSIDIZED,  - Origination Date: 2020-11-17
- **Name**: DIRECT STAFFORD UNSUBSIDIZED,  - Origination Date: 2019-10-24
- **Name**: DIRECT CONSOLIDATED UNSUBSIDIZED,  - Origination Date: 2024-08-08

### Income Based Repayment 2014
- **New Starting Monthly Payment**: $0.00
- **Loan Term (Months)**: N/A
- **Total Amount Paid Over Loan Term**: $0.00
- **Amount Forgiven**: $0.00
- **Eligible Loan Count**: 3
#### Eligible Loans:
- **Name**: DIRECT CONSOLIDATED UNSUBSIDIZED,  - Origination Date: 2024-08-08
- **Name**: DIRECT STAFFORD UNSUBSIDIZED,  - Origination Date: 2020-11-17
- **Name**: DIRECT STAFFORD UNSUBSIDIZED,  - Origination Date: 2019-10-24
"""

TOOL_MESSAGE_CONTENT_TEMPLATE = """[TOOL OUTPUT: {output_type}]
{artifact_section}

[Returned Data]
{returned_data}
"""

ARTIFACT_SECTION_TEMPLATE = """- Tool call ID: {tool_call_id}
- Artifact rendered to user: {artifact_rendered}
- Artifact name: {artifact_name}
- Artifact description: {artifact_description}
"""

OUTPUT_TYPE_ARTIFACT = "ARTIFACT DISPLAYED TO USER"
OUTPUT_TYPE_ARTIFACT_NO_RENDER = "NO ARTIFACT DISPLAYED TO USER"
OUTPUT_TYPE_DATA_ONLY = "DATA ONLY"


def format_tool_message_content(
    tool_call_id: str,
    artifact_rendered: bool,
    data_only: bool,
    artifact_name: str | None = None,
    artifact_description: str | None = None,
    returned_data: str | dict | None = None,
) -> str:
    """
    Formats tool message content in a standardized format across all tools.

    Args:
        tool_call_id: The ID of the tool call.
        artifact_rendered: Whether the artifact was rendered to the user.
        data_only: Whether this is a data-only response with no artifact.
        artifact_name: The name of the artifact.
        artifact_description: The description of the artifact.
        returned_data: The data returned by the tool.

    Returns:
        The formatted tool message content.
    """
    # Determine output type
    if data_only:
        output_type_value = OUTPUT_TYPE_DATA_ONLY
    elif artifact_rendered:
        output_type_value = OUTPUT_TYPE_ARTIFACT
    else:
        output_type_value = OUTPUT_TYPE_ARTIFACT_NO_RENDER
    # Format artifact section if not data-only
    artifact_section = ""
    if not data_only:
        artifact_section = ARTIFACT_SECTION_TEMPLATE.format(
            tool_call_id=tool_call_id,
            artifact_rendered=artifact_rendered,
            artifact_name=artifact_name,
            artifact_description=artifact_description
        )

    # Handle optional returned_data with proper dict formatting
    if returned_data is None:
        formatted_returned_data = ""
    elif isinstance(returned_data, dict):
        # Format dict as indented JSON for better readability
        formatted_returned_data = json.dumps(returned_data, indent=2, ensure_ascii=False)
    else:
        # Use as-is for strings
        formatted_returned_data = returned_data

    return TOOL_MESSAGE_CONTENT_TEMPLATE.format(
        output_type=output_type_value,
        artifact_section=artifact_section,
        returned_data=formatted_returned_data
    )


def format_tool_error(error_message: str | None, default_error_message: str) -> str:
    """
    Error formatter for agent tools. Currently, there are two expected types of errors
    that are intentionally not caught, so they can be returned as context to the agent:
    1. Validation errors on input parameters for a tool. These are generated by a Pydantic
       class model validator with its mode set to "after."
    2. API errors from clients used by agent tools. Currently, this is limited to the
       Candidly API.

    Validation errors generally start with "Value error, error_message".

    Candidly API errors are usually structured like this: {"error": "error_message"}.

    As we expand tool capabilities in the future, we will want to update this function
    to handle new types of errors.

    Args:
        error_message: The error message returned by the tool, stringified, or None.
        default_error_message: The default error message to return if the error message is not
        one of the expected types.

    Returns:
        The formatted tool error message.
    """
    if not error_message:
        return default_error_message

    cleaned = error_message.strip()

    if not cleaned:
        return default_error_message

    # Check for intentional validation errors
    if "Value error" in cleaned:
        # Consistently ends with : "[type=value_error,"
        match = re.search(r"Value error, (.*) \[type=value_error", cleaned)
        if match:
            return match.group(1)

    # Check for intentional client errors
    if "{\"error\":" in cleaned:
        match = re.search(r"\{\s*\"error\"\s*:\s*\"(.*?)\"\s*\}", cleaned)
        if match:
            return match.group(1)

    # if we get here, this is an error we do not expect from inside a tool
    return default_error_message
